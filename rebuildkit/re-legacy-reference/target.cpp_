#include "target.h"

#include <ghc/filesystem.hpp>

#include <cassert>

namespace re
{
    static constexpr auto kTargetConfigFilename = "re.yml";
    static constexpr auto kReSourceExtension = ".re";

    TargetType TargetTypeFromString(const String &type)
    {
        if (type == "project")
            return TargetType::Project;
        else if (type == "executable")
            return TargetType::Executable;
        else if (type == "static-library")
            return TargetType::StaticLibrary;
        else if (type == "shared-library")
            return TargetType::SharedLibrary;
        else
            assert(false && "Invalid target type");
    }

    Target::Target()
    {
    }

    bool DoesDirContainTarget(const String &path)
    {
        ghc::filesystem::path fspath{path};

        if (FILE *file = std::fopen((fspath / kTargetConfigFilename).string().c_str(), "r"))
        {
            std::fclose(file);
            return true;
        }
        else
            return false;
    }

    void WalkTargetTree(Target &target, String path = "", String src_module_path = "")
    {
        if (path.empty())
            path = target.path;

        ghc::filesystem::path fspath{path};
        std::string dirname = fspath.filename().string();

        // rpnint" -- DEBUG: Traversing '%s' srcmodpath='%s'\n", fspath.string().c_str(), src_module_path.c_str());

        if (src_module_path.empty())
            src_module_path = target.module;

        for (auto &entry : ghc::filesystem::directory_iterator{path})
        {
            if (entry.is_directory())
            {
                if (DoesDirContainTarget(entry.path().string()))
                {
                    Target child = LoadTargetFromDir(entry.path().string(), &target);
                    target.children.push_back(child);
                }
                else
                    WalkTargetTree(target, entry.path().string(),
                                   ModulePathCombine(src_module_path, entry.path().filename().string()));
            }

            if (entry.is_regular_file() && entry.path().extension() == kReSourceExtension)
                target.sources.push_back(SourceFile{entry.path().string(), src_module_path});
        }
    }

    void InitCodeTarget(Target &target)
    {
    }

    Target LoadTargetFromDir(const String &path, Target *pParent)
    {
        ghc::filesystem::path fspath{path};
        std::string name = fspath.filename().string();

        Target target;

        target.config = YAML::LoadFile((fspath / kTargetConfigFilename).string());
        target.path = path;

        target.name = fspath.filename().string();

        target.type_str = target.config["type"].as<std::string>();
        target.type = TargetTypeFromString(target.type_str);

        target.module = pParent ? pParent->module : "";

        if (target.config["root-module"] && target.config["root-module"].as<bool>() == true)
            target.module = "";

        if (target.config["deps"])
        {
            for (const auto& dep : target.config["deps"])
            {
                auto str = dep.as<std::string>();
                                
                if (str.front() == '.') // Special case: "this module"
                {
                    str.erase(0, 1);
                    str = ModulePathCombine(target.module, str);
                }

                target.deps.push_back(str);
            }
        }

        if (target.config["module-name"])
            target.module = ModulePathCombine(target.module, target.config["module-name"].as<std::string>());
        else
            target.module = ModulePathCombine(target.module, target.name);

        WalkTargetTree(target);

        return target;
    }
} // namespace re
